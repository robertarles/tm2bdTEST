{"id":"tm2db-2xd","title":"Build ID mapping system for TM↔Beads correlation","description":"## Description\nCreate a persistent ID mapping structure that tracks task-master IDs to Beads hash IDs for epics and hierarchical child IDs, with JSON serialization\n\n## Implementation Details\nCreate src/mapping/id-mapper.ts:\n```typescript\nimport fs from 'fs/promises';\nimport path from 'path';\n\nexport interface TaskMapping {\n  tmId: number;\n  beadsId: string;\n  type: 'epic';\n  subtasks: SubtaskMapping[];\n}\n\nexport interface SubtaskMapping {\n  tmId: number;\n  beadsId: string;\n  type: 'child';\n}\n\nexport interface MappingFile {\n  version: string;\n  generatedAt: string;\n  tasks: TaskMapping[];\n}\n\nexport class IdMapper {\n  private tasks: TaskMapping[] = [];\n\n  addEpic(tmId: number, beadsId: string): void {\n    this.tasks.push({\n      tmId,\n      beadsId,\n      type: 'epic',\n      subtasks: []\n    });\n  }\n\n  addSubtask(taskTmId: number, subtaskTmId: number, beadsId: string): void {\n    const task = this.tasks.find(t =\u003e t.tmId === taskTmId);\n    if (!task) throw new Error(`Task ${taskTmId} not found in mapping`);\n    task.subtasks.push({\n      tmId: subtaskTmId,\n      beadsId,\n      type: 'child'\n    });\n  }\n\n  getEpicId(tmId: number): string | undefined {\n    return this.tasks.find(t =\u003e t.tmId === tmId)?.beadsId;\n  }\n\n  getSubtaskId(taskTmId: number, subtaskTmId: number): string | undefined {\n    const task = this.tasks.find(t =\u003e t.tmId === taskTmId);\n    return task?.subtasks.find(s =\u003e s.tmId === subtaskTmId)?.beadsId;\n  }\n\n  async save(filePath: string): Promise\u003cvoid\u003e {\n    const data: MappingFile = {\n      version: '1.0',\n      generatedAt: new Date().toISOString(),\n      tasks: this.tasks\n    };\n    await fs.writeFile(filePath, JSON.stringify(data, null, 2), 'utf-8');\n  }\n\n  static async load(filePath: string): Promise\u003cIdMapper\u003e {\n    const content = await fs.readFile(filePath, 'utf-8');\n    const data: MappingFile = JSON.parse(content);\n    const mapper = new IdMapper();\n    mapper.tasks = data.tasks;\n    return mapper;\n  }\n\n  static async exists(filePath: string): Promise\u003cboolean\u003e {\n    try {\n      await fs.access(filePath);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n}\n```\n\n## Test Strategy\nUnit tests:\n1. Add epic and retrieve by TM ID - should return correct Beads ID\n2. Add subtask and retrieve by parent TM ID + subtask TM ID\n3. Save to file and load - should preserve all mappings\n4. exists() - should correctly detect file presence\n5. Error handling for missing task when adding subtask\nVerify JSON format matches MappingFile interface.\n\n## Metadata\n- Task-Master ID: 5\n- Complexity: 3/10\n- Original Status: done","status":"closed","priority":1,"issue_type":"epic","owner":"robert@arles.us","created_at":"2026-02-21T01:02:41Z","created_by":"robert","updated_at":"2026-02-21T01:03:18Z","closed_at":"2026-02-21T01:03:18Z","close_reason":"Closed","dependencies":[{"issue_id":"tm2db-2xd","depends_on_id":"tm2db-brr","type":"blocks","created_at":"2026-02-20T17:02:57Z","created_by":"robert","metadata":"{}"}]}
{"id":"tm2db-2xd.1","title":"Implement IdMapper class with in-memory mapping data structures","description":"Create the core IdMapper class with in-memory data structures for tracking TM→Beads ID mappings, implementing addEpic, addSubtask, getEpicId, and getSubtaskId methods\n\n## Implementation Details\nImplement the IdMapper class in src/mapping/id-mapper.ts with:\n- Private tasks array to store TaskMapping objects\n- addEpic(tmId, beadsId) method to add epic-level mappings\n- addSubtask(taskTmId, subtaskTmId, beadsId) method to add child mappings with validation\n- getEpicId(tmId) method to retrieve Beads epic ID from TM task ID\n- getSubtaskId(taskTmId, subtaskTmId) method to retrieve Beads child ID from TM task+subtask IDs\n- Error handling for missing tasks when adding subtasks\n- Type definitions for TaskMapping, SubtaskMapping interfaces\n\nFocus purely on the in-memory lookup logic without any file I/O concerns.","status":"open","priority":2,"issue_type":"task","owner":"robert@arles.us","created_at":"2026-02-21T01:02:49Z","created_by":"robert","updated_at":"2026-02-21T01:02:49Z","dependencies":[{"issue_id":"tm2db-2xd.1","depends_on_id":"tm2db-2xd","type":"parent-child","created_at":"2026-02-20T17:02:49Z","created_by":"robert","metadata":"{}"}]}
{"id":"tm2db-2xd.2","title":"Implement JSON persistence layer with save/load/exists methods","description":"Add file I/O functionality to IdMapper class for persisting and loading mapping data from JSON files, including version metadata and error handling\n\n## Implementation Details\nExtend the IdMapper class with persistence methods:\n- save(filePath) async method that serializes tasks array to MappingFile format with version '1.0' and generatedAt timestamp, writes to file with proper formatting (2-space indent)\n- static load(filePath) async method that reads JSON file, parses into MappingFile, creates new IdMapper instance and hydrates tasks array\n- static exists(filePath) async method that checks file accessibility, returns true if exists, false otherwise (catches access errors)\n- MappingFile interface definition with version, generatedAt, tasks fields\n- Proper async/await error propagation for file operations\n\nSeparate all file I/O concerns from the in-memory logic implemented in subtask 1.","status":"open","priority":2,"issue_type":"task","owner":"robert@arles.us","created_at":"2026-02-21T01:02:50Z","created_by":"robert","updated_at":"2026-02-21T01:02:50Z","dependencies":[{"issue_id":"tm2db-2xd.2","depends_on_id":"tm2db-2xd","type":"parent-child","created_at":"2026-02-20T17:02:49Z","created_by":"robert","metadata":"{}"},{"issue_id":"tm2db-2xd.2","depends_on_id":"tm2db-2xd.1","type":"blocks","created_at":"2026-02-20T17:03:11Z","created_by":"robert","metadata":"{}"}]}
{"id":"tm2db-7qc","title":"Create status synchronization logic","description":"## Description\nImplement post-creation status updates to sync task-master statuses (in-progress, done, deferred) to corresponding Beads issue states\n\n## Implementation Details\nCreate src/sync/status-syncer.ts:\n```typescript\nimport { TaskMasterTask } from '../schemas/taskmaster';\nimport { BeadsCli } from '../beads/cli';\nimport { IdMapper } from '../mapping/id-mapper';\n\nfunction mapStatus(tmStatus: string): { status?: string; close: boolean } {\n  const statusMap: Record\u003cstring, { status?: string; close: boolean }\u003e = {\n    'pending': { close: false }, // default, no action\n    'in-progress': { status: 'in_progress', close: false },\n    'done': { close: true },\n    'deferred': { status: 'deferred', close: false }\n  };\n  return statusMap[tmStatus] || { close: false };\n}\n\nexport async function syncEpicStatus(\n  task: TaskMasterTask,\n  cli: BeadsCli,\n  mapper: IdMapper\n): Promise\u003cvoid\u003e {\n  const epicId = mapper.getEpicId(task.id);\n  if (!epicId) throw new Error(`Epic ID not found for task ${task.id}`);\n  \n  const { status, close } = mapStatus(task.status);\n  \n  if (close) {\n    await cli.close(epicId);\n  } else if (status) {\n    await cli.updateStatus(epicId, status);\n  }\n}\n\nexport async function syncSubtaskStatus(\n  task: TaskMasterTask,\n  cli: BeadsCli,\n  mapper: IdMapper\n): Promise\u003cvoid\u003e {\n  if (!task.subtasks) return;\n  \n  for (const subtask of task.subtasks) {\n    const subtaskId = mapper.getSubtaskId(task.id, subtask.id);\n    if (!subtaskId) throw new Error(`Subtask ID not found for ${task.id}.${subtask.id}`);\n    \n    const { status, close } = mapStatus(subtask.status);\n    \n    if (close) {\n      await cli.close(subtaskId);\n    } else if (status) {\n      await cli.updateStatus(subtaskId, status);\n    }\n  }\n}\n\nexport async function syncAllStatuses(\n  tasks: TaskMasterTask[],\n  cli: BeadsCli,\n  mapper: IdMapper\n): Promise\u003cvoid\u003e {\n  for (const task of tasks) {\n    await syncEpicStatus(task, cli, mapper);\n    await syncSubtaskStatus(task, cli, mapper);\n  }\n}\n```\n\n## Test Strategy\nUnit tests:\n1. mapStatus() for each TM status - verify correct Beads mapping\n2. syncEpicStatus() with 'done' - verify close() called\n3. syncEpicStatus() with 'in-progress' - verify updateStatus() called\n4. syncEpicStatus() with 'pending' - verify no CLI calls\n5. syncSubtaskStatus() - verify all subtasks processed\n6. syncAllStatuses() - verify both epic and subtask sync\nMock BeadsCli and IdMapper.\n\n## Metadata\n- Task-Master ID: 9\n- Complexity: 3/10\n- Original Status: done","status":"closed","priority":1,"issue_type":"epic","owner":"robert@arles.us","created_at":"2026-02-21T01:02:42Z","created_by":"robert","updated_at":"2026-02-21T01:03:20Z","closed_at":"2026-02-21T01:03:20Z","close_reason":"Closed","dependencies":[{"issue_id":"tm2db-7qc","depends_on_id":"tm2db-2xd","type":"blocks","created_at":"2026-02-20T17:03:02Z","created_by":"robert","metadata":"{}"},{"issue_id":"tm2db-7qc","depends_on_id":"tm2db-aec","type":"blocks","created_at":"2026-02-20T17:03:01Z","created_by":"robert","metadata":"{}"}]}
{"id":"tm2db-7qc.1","title":"Implement mapStatus() helper and syncEpicStatus() function","description":"Create the status mapping helper that translates task-master statuses to Beads operations, and implement the epic-level status synchronization function with proper error handling for missing IDs\n\n## Implementation Details\nIn src/sync/status-syncer.ts, implement:\n1. mapStatus() function with lookup table for pending (no-op), in-progress (updateStatus), done (close), and deferred (updateStatus)\n2. syncEpicStatus() function that:\n   - Retrieves epic ID from mapper using task.id\n   - Throws descriptive error if epic ID not found\n   - Calls cli.close() for 'done' status\n   - Calls cli.updateStatus() for statuses that require updates\n   - Skips CLI calls for 'pending' status\n3. Import required types from TaskMasterTask, BeadsCli, and IdMapper\n4. Use TypeScript return type { status?: string; close: boolean } for mapStatus()\n5. Ensure proper async/await handling","status":"open","priority":2,"issue_type":"task","owner":"robert@arles.us","created_at":"2026-02-21T01:02:51Z","created_by":"robert","updated_at":"2026-02-21T01:02:51Z","dependencies":[{"issue_id":"tm2db-7qc.1","depends_on_id":"tm2db-7qc","type":"parent-child","created_at":"2026-02-20T17:02:51Z","created_by":"robert","metadata":"{}"}]}
{"id":"tm2db-7qc.2","title":"Implement syncSubtaskStatus() and syncAllStatuses() functions","description":"Create the subtask status synchronization logic that iterates through all subtasks and applies status updates, plus the orchestration function that synchronizes statuses for all tasks and their subtasks in the correct order\n\n## Implementation Details\nIn src/sync/status-syncer.ts, implement:\n1. syncSubtaskStatus() function that:\n   - Returns early if task.subtasks is undefined/empty\n   - Iterates through all subtasks in the task\n   - Retrieves subtask ID from mapper using task.id and subtask.id\n   - Throws error if subtask ID not found\n   - Calls mapStatus() to determine operation\n   - Executes cli.close() or cli.updateStatus() as appropriate\n2. syncAllStatuses() orchestration function that:\n   - Iterates through all tasks in order\n   - Calls syncEpicStatus() for each task\n   - Calls syncSubtaskStatus() for each task\n   - Properly propagates errors\n3. Ensure all functions use proper async/await and error handling\n4. Export all public functions","status":"open","priority":2,"issue_type":"task","owner":"robert@arles.us","created_at":"2026-02-21T01:02:52Z","created_by":"robert","updated_at":"2026-02-21T01:02:52Z","dependencies":[{"issue_id":"tm2db-7qc.2","depends_on_id":"tm2db-7qc","type":"parent-child","created_at":"2026-02-20T17:02:51Z","created_by":"robert","metadata":"{}"},{"issue_id":"tm2db-7qc.2","depends_on_id":"tm2db-7qc.1","type":"blocks","created_at":"2026-02-20T17:03:14Z","created_by":"robert","metadata":"{}"}]}
{"id":"tm2db-9sz","title":"Build CLI interface with Commander and orchestrate sync pipeline","description":"## Description\nCreate the main CLI entry point with argument parsing, dry-run mode, idempotency checks, resume capability, and orchestrate the complete sync pipeline with progress reporting\n\n## Implementation Details\nCreate src/index.ts:\n```typescript\nimport { Command } from 'commander';\nimport chalk from 'chalk';\nimport { parseTasksJson } from './schemas/taskmaster';\nimport { topologicalSort } from './utils/topological-sort';\nimport { BeadsCli } from './beads/cli';\nimport { IdMapper } from './mapping/id-mapper';\nimport { createEpics } from './sync/epic-creator';\nimport { createAllChildren } from './sync/child-creator';\nimport { wireAllDependencies } from './sync/dependency-wirer';\nimport { syncAllStatuses } from './sync/status-syncer';\n\nconst program = new Command();\n\nprogram\n  .name('tm2bd')\n  .description('Task-Master to Beads sync tool')\n  .version('1.0.0');\n\nprogram\n  .command('sync')\n  .description('Sync task-master tasks to Beads')\n  .option('--tasks \u003cpath\u003e', 'Path to tasks.json', '.tasks/tasks.json')\n  .option('--project \u003cpath\u003e', 'Path to project root with .beads/', '.')\n  .option('--dry-run', 'Print commands without executing')\n  .option('--force', 'Overwrite existing import')\n  .option('--resume', 'Resume from partial mapping file')\n  .option('--map-file \u003cpath\u003e', 'Path for ID mapping output', './tm2bd-map.json')\n  .option('-v, --verbose', 'Verbose output')\n  .action(async (options) =\u003e {\n    try {\n      console.log(chalk.bold('tm2bd: Task-Master to Beads Sync'));\n      \n      // Check Beads init\n      const cli = new BeadsCli(options.project, options.verbose);\n      const isInit = await cli.checkInit();\n      if (!isInit) {\n        console.error(chalk.red('Error: Beads not initialized. Run `bd init` first.'));\n        process.exit(1);\n      }\n      \n      // Idempotency check\n      const mapExists = await IdMapper.exists(options.mapFile);\n      if (mapExists \u0026\u0026 !options.force \u0026\u0026 !options.resume) {\n        console.error(chalk.red(`Error: Mapping file ${options.mapFile} exists. Use --force or --resume.`));\n        process.exit(1);\n      }\n      \n      // Load or create mapper\n      let mapper: IdMapper;\n      if (options.resume \u0026\u0026 mapExists) {\n        console.log(chalk.yellow('Resuming from existing mapping...'));\n        mapper = await IdMapper.load(options.mapFile);\n      } else {\n        mapper = new IdMapper();\n      }\n      \n      // Parse and validate\n      console.log(chalk.blue('Parsing tasks.json...'));\n      const project = await parseTasksJson(options.tasks);\n      console.log(chalk.green(`✓ Loaded ${project.tasks.length} tasks`));\n      \n      // Topological sort\n      console.log(chalk.blue('Sorting by dependencies...'));\n      const sorted = topologicalSort(project.tasks);\n      const sortedTasks = sorted.map(s =\u003e s.task);\n      console.log(chalk.green(`✓ Sorted into ${Math.max(...sorted.map(s =\u003e s.tier)) + 1} dependency tiers`));\n      \n      if (options.dryRun) {\n        console.log(chalk.yellow('\\n[DRY RUN MODE - No changes will be made]\\n'));\n        // Print commands that would be executed\n        process.exit(0);\n      }\n      \n      // Create epics\n      console.log(chalk.blue('Creating epics...'));\n      await createEpics(sortedTasks, cli, mapper, (cur, tot) =\u003e {\n        console.log(chalk.gray(`  ${cur}/${tot} epics created`));\n      });\n      console.log(chalk.green('✓ All epics created'));\n      \n      // Create children\n      console.log(chalk.blue('Creating child tasks...'));\n      await createAllChildren(project.tasks, cli, mapper);\n      console.log(chalk.green('✓ All children created'));\n      \n      // Wire dependencies\n      console.log(chalk.blue('Wiring dependencies...'));\n      await wireAllDependencies(project.tasks, cli, mapper);\n      console.log(chalk.green('✓ All dependencies wired'));\n      \n      // Sync statuses\n      console.log(chalk.blue('Synchronizing statuses...'));\n      await syncAllStatuses(project.tasks, cli, mapper);\n      console.log(chalk.green('✓ All statuses synchronized'));\n      \n      // Save mapping\n      await mapper.save(options.mapFile);\n      console.log(chalk.green(`✓ Mapping saved to ${options.mapFile}`));\n      \n      console.log(chalk.bold.green('\\n✓ Sync complete!'));\n    } catch (error) {\n      console.error(chalk.red('Error:'), error instanceof Error ? error.message : error);\n      process.exit(1);\n    }\n  });\n\nprogram.parse();\n```\n\nUpdate package.json bin:\n```json\n{\n  \"name\": \"tm2bd\",\n  \"bin\": {\n    \"tm2bd\": \"./dist/index.js\"\n  }\n}\n```\n\n## Test Strategy\nIntegration tests:\n1. Create fixture tasks.json with variety of scenarios\n2. Test full sync pipeline in temp directory with bd init\n3. Test --dry-run prints without executing\n4. Test idempotency check prevents duplicate imports\n5. Test --force overrides idempotency\n6. Test --resume loads partial mapping\n7. Test error handling for missing .beads/\n8. Test progress reporting callbacks\n9. Manual end-to-end test:\n   - Run on real task-master project\n   - Verify `bd list` shows all epics\n   - Verify `bd ready` surfaces unblocked work\n   - Verify `bd dep tree` shows dependencies\n   - Verify `bd show \u003cid\u003e` has full descriptions\n\n## Metadata\n- Task-Master ID: 10\n- Complexity: 8/10\n- Original Status: done","status":"closed","priority":0,"issue_type":"epic","owner":"robert@arles.us","created_at":"2026-02-21T01:02:43Z","created_by":"robert","updated_at":"2026-02-21T01:03:20Z","closed_at":"2026-02-21T01:03:20Z","close_reason":"Closed","dependencies":[{"issue_id":"tm2db-9sz","depends_on_id":"tm2db-2xd","type":"blocks","created_at":"2026-02-20T17:03:03Z","created_by":"robert","metadata":"{}"},{"issue_id":"tm2db-9sz","depends_on_id":"tm2db-7qc","type":"blocks","created_at":"2026-02-20T17:03:05Z","created_by":"robert","metadata":"{}"},{"issue_id":"tm2db-9sz","depends_on_id":"tm2db-a66","type":"blocks","created_at":"2026-02-20T17:03:05Z","created_by":"robert","metadata":"{}"},{"issue_id":"tm2db-9sz","depends_on_id":"tm2db-aec","type":"blocks","created_at":"2026-02-20T17:03:03Z","created_by":"robert","metadata":"{}"},{"issue_id":"tm2db-9sz","depends_on_id":"tm2db-brr","type":"blocks","created_at":"2026-02-20T17:03:02Z","created_by":"robert","metadata":"{}"},{"issue_id":"tm2db-9sz","depends_on_id":"tm2db-bv0","type":"blocks","created_at":"2026-02-20T17:03:03Z","created_by":"robert","metadata":"{}"},{"issue_id":"tm2db-9sz","depends_on_id":"tm2db-s4n","type":"blocks","created_at":"2026-02-20T17:03:04Z","created_by":"robert","metadata":"{}"},{"issue_id":"tm2db-9sz","depends_on_id":"tm2db-zhm","type":"blocks","created_at":"2026-02-20T17:03:04Z","created_by":"robert","metadata":"{}"}]}
{"id":"tm2db-9sz.1","title":"Implement Commander CLI argument parsing and validation with all specified options","description":"Set up Commander.js CLI interface with all required options (--tasks, --project, --dry-run, --force, --resume, --map-file, --verbose) and implement argument validation to ensure proper paths and option combinations\n\n## Implementation Details\nCreate src/index.ts with Commander program setup. Define the 'sync' command with all 7 options. Implement basic validation: check that paths are strings, boolean flags are parsed correctly, and provide default values (tasks: '.tasks/tasks.json', project: '.', map-file: './tm2bd-map.json'). Add program name, description, and version. Set up the main action handler structure that will contain the sync logic. Ensure TypeScript types are properly inferred from Commander's option parsing.","status":"open","priority":2,"issue_type":"task","owner":"robert@arles.us","created_at":"2026-02-21T01:02:55Z","created_by":"robert","updated_at":"2026-02-21T01:02:55Z","dependencies":[{"issue_id":"tm2db-9sz.1","depends_on_id":"tm2db-9sz","type":"parent-child","created_at":"2026-02-20T17:02:54Z","created_by":"robert","metadata":"{}"}]}
{"id":"tm2db-9sz.2","title":"Implement idempotency checks and Beads initialization verification","description":"Add precondition validation including Beads initialization check, mapping file existence detection, and --force/--resume conflict resolution logic with appropriate error messages and exit codes\n\n## Implementation Details\nImplement BeadsCli.checkInit() call to verify .beads/ directory exists before proceeding. Add IdMapper.exists() check for mapping file. Implement three-way logic: (1) If map file exists and neither --force nor --resume: error and exit(1), (2) If --resume and map exists: load existing mapper with IdMapper.load(), (3) If --force or no map exists: create new IdMapper(). Add colored chalk error messages for each failure scenario. Ensure exit codes are correct (1 for errors, 0 for success).","status":"open","priority":2,"issue_type":"task","owner":"robert@arles.us","created_at":"2026-02-21T01:02:55Z","created_by":"robert","updated_at":"2026-02-21T01:02:55Z","dependencies":[{"issue_id":"tm2db-9sz.2","depends_on_id":"tm2db-9sz","type":"parent-child","created_at":"2026-02-20T17:02:55Z","created_by":"robert","metadata":"{}"},{"issue_id":"tm2db-9sz.2","depends_on_id":"tm2db-9sz.1","type":"blocks","created_at":"2026-02-20T17:03:14Z","created_by":"robert","metadata":"{}"}]}
{"id":"tm2db-9sz.3","title":"Implement main sync pipeline orchestration with error handling","description":"Build the complete sync pipeline that calls parseTasksJson, topologicalSort, createEpics, createAllChildren, wireAllDependencies, syncAllStatuses in correct order with comprehensive try-catch error handling and process exit management\n\n## Implementation Details\nIn the action handler, implement the full pipeline: (1) parseTasksJson(options.tasks) with count reporting, (2) topologicalSort(project.tasks) with tier count reporting, (3) Skip dry-run block for now (subtask 4), (4) createEpics() with sorted tasks and progress callback, (5) createAllChildren() with all tasks, (6) wireAllDependencies() with all tasks, (7) syncAllStatuses() with all tasks, (8) mapper.save(options.mapFile). Wrap entire pipeline in try-catch that logs error.message with chalk.red and calls process.exit(1). Ensure all async operations are properly awaited.","status":"open","priority":2,"issue_type":"task","owner":"robert@arles.us","created_at":"2026-02-21T01:02:56Z","created_by":"robert","updated_at":"2026-02-21T01:02:56Z","dependencies":[{"issue_id":"tm2db-9sz.3","depends_on_id":"tm2db-9sz","type":"parent-child","created_at":"2026-02-20T17:02:55Z","created_by":"robert","metadata":"{}"},{"issue_id":"tm2db-9sz.3","depends_on_id":"tm2db-9sz.2","type":"blocks","created_at":"2026-02-20T17:03:15Z","created_by":"robert","metadata":"{}"}]}
{"id":"tm2db-9sz.4","title":"Implement dry-run mode that prints commands without execution","description":"Add dry-run mode implementation that detects --dry-run flag and prints all bd CLI commands that would be executed without actually running them, then exits with code 0\n\n## Implementation Details\nAfter topological sort in the pipeline, check if options.dryRun is true. If so, print chalk.yellow warning '[DRY RUN MODE - No changes will be made]'. Iterate through sorted tasks and print what commands would be executed: bd epic create for each task, bd create for each subtask with parent ID, bd dep add for each dependency, bd update for status changes. Format output to show command structure clearly. Call process.exit(0) after printing. Consider adding a --dry-run flag to BeadsCli constructor to make it print instead of execute, or implement separate dry-run logic in sync functions.","status":"open","priority":2,"issue_type":"task","owner":"robert@arles.us","created_at":"2026-02-21T01:02:56Z","created_by":"robert","updated_at":"2026-02-21T01:02:56Z","dependencies":[{"issue_id":"tm2db-9sz.4","depends_on_id":"tm2db-9sz","type":"parent-child","created_at":"2026-02-20T17:02:55Z","created_by":"robert","metadata":"{}"},{"issue_id":"tm2db-9sz.4","depends_on_id":"tm2db-9sz.3","type":"blocks","created_at":"2026-02-20T17:03:15Z","created_by":"robert","metadata":"{}"}]}
{"id":"tm2db-9sz.5","title":"Implement progress reporting, mapping persistence, and colored output","description":"Add comprehensive progress reporting with chalk-colored console output for each pipeline phase, implement progress callbacks for epic creation, add final success message, and ensure mapping file is saved correctly\n\n## Implementation Details\nAdd chalk.bold header 'tm2bd: Task-Master to Beads Sync' at start. For each phase, add chalk.blue 'Processing...' message before and chalk.green '✓ Complete' after. In createEpics call, pass progress callback: (cur, tot) =\u003e console.log(chalk.gray(`  ${cur}/${tot} epics created`)). Add count reporting: '✓ Loaded N tasks', '✓ Sorted into N tiers', '✓ All epics created', '✓ All children created', '✓ All dependencies wired', '✓ All statuses synchronized'. Add final chalk.bold.green '✓ Sync complete!' message. Ensure mapper.save() is called and logged with '✓ Mapping saved to {path}'. Update package.json bin field to point to ./dist/index.js with shebang.","status":"open","priority":2,"issue_type":"task","owner":"robert@arles.us","created_at":"2026-02-21T01:02:56Z","created_by":"robert","updated_at":"2026-02-21T01:02:56Z","dependencies":[{"issue_id":"tm2db-9sz.5","depends_on_id":"tm2db-9sz","type":"parent-child","created_at":"2026-02-20T17:02:56Z","created_by":"robert","metadata":"{}"},{"issue_id":"tm2db-9sz.5","depends_on_id":"tm2db-9sz.3","type":"blocks","created_at":"2026-02-20T17:03:16Z","created_by":"robert","metadata":"{}"}]}
{"id":"tm2db-a66","title":"Build dependency wiring for cross-epic and intra-epic blocks","description":"## Description\nImplement logic to create Beads 'blocks' dependencies between epics (for task dependencies) and between children within epics (for subtask dependencies)\n\n## Implementation Details\nCreate src/sync/dependency-wirer.ts:\n```typescript\nimport { TaskMasterTask } from '../schemas/taskmaster';\nimport { BeadsCli } from '../beads/cli';\nimport { IdMapper } from '../mapping/id-mapper';\n\nexport async function wireEpicDependencies(\n  tasks: TaskMasterTask[],\n  cli: BeadsCli,\n  mapper: IdMapper\n): Promise\u003cvoid\u003e {\n  for (const task of tasks) {\n    if (task.dependencies.length === 0) continue;\n    \n    const blockedEpicId = mapper.getEpicId(task.id);\n    if (!blockedEpicId) throw new Error(`Epic ID not found for task ${task.id}`);\n    \n    for (const depId of task.dependencies) {\n      const blockingEpicId = mapper.getEpicId(depId);\n      if (!blockingEpicId) throw new Error(`Epic ID not found for dependency ${depId}`);\n      \n      // bd dep add \u003cblocked\u003e \u003cblocking\u003e\n      await cli.addDependency(blockedEpicId, blockingEpicId);\n    }\n  }\n}\n\nexport async function wireSubtaskDependencies(\n  tasks: TaskMasterTask[],\n  cli: BeadsCli,\n  mapper: IdMapper\n): Promise\u003cvoid\u003e {\n  for (const task of tasks) {\n    if (!task.subtasks) continue;\n    \n    for (const subtask of task.subtasks) {\n      if (!subtask.dependencies || subtask.dependencies.length === 0) continue;\n      \n      const blockedId = mapper.getSubtaskId(task.id, subtask.id);\n      if (!blockedId) throw new Error(`Subtask ID not found for ${task.id}.${subtask.id}`);\n      \n      for (const depId of subtask.dependencies) {\n        const blockingId = mapper.getSubtaskId(task.id, depId);\n        if (!blockingId) throw new Error(`Subtask ID not found for dependency ${task.id}.${depId}`);\n        \n        await cli.addDependency(blockedId, blockingId);\n      }\n    }\n  }\n}\n\nexport async function wireAllDependencies(\n  tasks: TaskMasterTask[],\n  cli: BeadsCli,\n  mapper: IdMapper\n): Promise\u003cvoid\u003e {\n  await wireEpicDependencies(tasks, cli, mapper);\n  await wireSubtaskDependencies(tasks, cli, mapper);\n}\n```\n\n## Test Strategy\nUnit tests with mocked BeadsCli:\n1. wireEpicDependencies() with no deps - no CLI calls\n2. wireEpicDependencies() with deps - verify correct blocked/blocking order\n3. wireSubtaskDependencies() with intra-epic deps - verify correct IDs\n4. Error handling for missing epic IDs in mapper\n5. Error handling for missing subtask IDs\n6. wireAllDependencies() - verify both functions called\nVerify bd dep add arguments match Beads syntax.\n\n## Metadata\n- Task-Master ID: 8\n- Complexity: 5/10\n- Original Status: done","status":"closed","priority":0,"issue_type":"epic","owner":"robert@arles.us","created_at":"2026-02-21T01:02:42Z","created_by":"robert","updated_at":"2026-02-21T01:03:19Z","closed_at":"2026-02-21T01:03:19Z","close_reason":"Closed","dependencies":[{"issue_id":"tm2db-a66","depends_on_id":"tm2db-2xd","type":"blocks","created_at":"2026-02-20T17:03:01Z","created_by":"robert","metadata":"{}"},{"issue_id":"tm2db-a66","depends_on_id":"tm2db-aec","type":"blocks","created_at":"2026-02-20T17:03:00Z","created_by":"robert","metadata":"{}"},{"issue_id":"tm2db-a66","depends_on_id":"tm2db-zhm","type":"blocks","created_at":"2026-02-20T17:03:01Z","created_by":"robert","metadata":"{}"}]}
{"id":"tm2db-a66.1","title":"Implement wireEpicDependencies() for cross-epic blocking","description":"Create the wireEpicDependencies() function to establish 'blocks' dependencies between top-level task epics using the ID mapper\n\n## Implementation Details\nImplement wireEpicDependencies() in src/sync/dependency-wirer.ts:\n- Iterate through all tasks checking for dependencies array\n- For each task with dependencies, use mapper.getEpicId(task.id) to get the blocked epic ID\n- For each dependency ID in task.dependencies, use mapper.getEpicId(depId) to get the blocking epic ID\n- Call cli.addDependency(blockedEpicId, blockingEpicId) with correct order (blocked first, blocking second)\n- Throw descriptive errors if epic IDs are not found in mapper, including the task ID that failed\n- Skip tasks with empty dependencies array","status":"open","priority":2,"issue_type":"task","owner":"robert@arles.us","created_at":"2026-02-21T01:02:53Z","created_by":"robert","updated_at":"2026-02-21T01:02:53Z","dependencies":[{"issue_id":"tm2db-a66.1","depends_on_id":"tm2db-a66","type":"parent-child","created_at":"2026-02-20T17:02:53Z","created_by":"robert","metadata":"{}"}]}
{"id":"tm2db-a66.2","title":"Implement wireSubtaskDependencies() for intra-epic blocking","description":"Create the wireSubtaskDependencies() function to establish 'blocks' dependencies between child issues within the same epic\n\n## Implementation Details\nImplement wireSubtaskDependencies() in src/sync/dependency-wirer.ts:\n- Iterate through all tasks, then through subtasks array if present\n- For each subtask with dependencies, use mapper.getSubtaskId(task.id, subtask.id) to get the blocked child ID\n- For each dependency ID in subtask.dependencies, use mapper.getSubtaskId(task.id, depId) to get the blocking child ID (note: sibling resolution within same parent)\n- Call cli.addDependency(blockedId, blockingId) with correct order\n- Throw descriptive errors if subtask IDs are not found in mapper, including both task.id and subtask.id in error message\n- Skip subtasks with no dependencies or empty dependencies array","status":"open","priority":2,"issue_type":"task","owner":"robert@arles.us","created_at":"2026-02-21T01:02:54Z","created_by":"robert","updated_at":"2026-02-21T01:02:54Z","dependencies":[{"issue_id":"tm2db-a66.2","depends_on_id":"tm2db-a66","type":"parent-child","created_at":"2026-02-20T17:02:53Z","created_by":"robert","metadata":"{}"},{"issue_id":"tm2db-a66.2","depends_on_id":"tm2db-a66.1","type":"blocks","created_at":"2026-02-20T17:03:13Z","created_by":"robert","metadata":"{}"}]}
{"id":"tm2db-a66.3","title":"Implement wireAllDependencies() orchestrator with error handling","description":"Create the wireAllDependencies() orchestration function and add comprehensive error handling throughout the dependency wiring module\n\n## Implementation Details\nImplement wireAllDependencies() and enhance error handling in src/sync/dependency-wirer.ts:\n- Create wireAllDependencies() that calls wireEpicDependencies() followed by wireSubtaskDependencies()\n- Ensure errors from either function propagate up with context preserved\n- Add try-catch blocks if needed to provide additional context about which phase failed (epic vs subtask wiring)\n- Verify all error messages include the specific task/subtask ID that caused the failure\n- Ensure error messages clearly indicate whether it's a missing epic ID or missing subtask ID\n- Consider adding progress logging if verbose mode is available from CLI wrapper","status":"open","priority":2,"issue_type":"task","owner":"robert@arles.us","created_at":"2026-02-21T01:02:54Z","created_by":"robert","updated_at":"2026-02-21T01:02:54Z","dependencies":[{"issue_id":"tm2db-a66.3","depends_on_id":"tm2db-a66","type":"parent-child","created_at":"2026-02-20T17:02:54Z","created_by":"robert","metadata":"{}"},{"issue_id":"tm2db-a66.3","depends_on_id":"tm2db-a66.1","type":"blocks","created_at":"2026-02-20T17:03:13Z","created_by":"robert","metadata":"{}"},{"issue_id":"tm2db-a66.3","depends_on_id":"tm2db-a66.2","type":"blocks","created_at":"2026-02-20T17:03:14Z","created_by":"robert","metadata":"{}"}]}
{"id":"tm2db-aec","title":"Create Beads CLI wrapper with command execution and JSON parsing","description":"## Description\nBuild a type-safe wrapper around bd CLI commands using execa, with support for --json output parsing, error handling, and command logging\n\n## Implementation Details\nCreate src/beads/cli.ts:\n```typescript\nimport { execa } from 'execa';\nimport { z } from 'zod';\n\nexport interface BeadsCreateResult {\n  id: string;\n  title: string;\n  type?: string;\n}\n\nconst BeadsCreateOutputSchema = z.object({\n  id: z.string(),\n  title: z.string(),\n  type: z.string().optional()\n});\n\nexport class BeadsCli {\n  constructor(\n    private projectPath: string,\n    private verbose: boolean = false\n  ) {}\n\n  private async exec(args: string[]): Promise\u003cstring\u003e {\n    if (this.verbose) {\n      console.log(`[bd] ${args.join(' ')}`);\n    }\n    const result = await execa('bd', args, { cwd: this.projectPath });\n    if (this.verbose \u0026\u0026 result.stdout) {\n      console.log(result.stdout);\n    }\n    return result.stdout;\n  }\n\n  async createEpic(title: string, description: string, priority: number): Promise\u003cBeadsCreateResult\u003e {\n    const args = ['create', title, '-t', 'epic', '-p', priority.toString(), '--json'];\n    if (description) {\n      args.push('-d', description);\n    }\n    const output = await this.exec(args);\n    return BeadsCreateOutputSchema.parse(JSON.parse(output));\n  }\n\n  async createChild(parentId: string, title: string, description: string): Promise\u003cBeadsCreateResult\u003e {\n    const args = ['create', title, '--parent', parentId, '--json'];\n    if (description) {\n      args.push('-d', description);\n    }\n    const output = await this.exec(args);\n    return BeadsCreateOutputSchema.parse(JSON.parse(output));\n  }\n\n  async addDependency(blockedId: string, blockingId: string): Promise\u003cvoid\u003e {\n    await this.exec(['dep', 'add', blockedId, blockingId]);\n  }\n\n  async updateStatus(issueId: string, status: string): Promise\u003cvoid\u003e {\n    await this.exec(['update', issueId, '-s', status]);\n  }\n\n  async close(issueId: string): Promise\u003cvoid\u003e {\n    await this.exec(['close', issueId]);\n  }\n\n  async checkInit(): Promise\u003cboolean\u003e {\n    try {\n      await execa('test', ['-d', '.beads'], { cwd: this.projectPath });\n      return true;\n    } catch {\n      return false;\n    }\n  }\n}\n```\n\n## Test Strategy\nCreate integration tests that require bd CLI:\n1. Mock execa calls and verify correct argument construction\n2. Test JSON parsing with sample bd create --json output\n3. Test error handling for failed commands\n4. Test verbose mode logging\n5. Verify checkInit() correctly detects .beads/ directory\nUse vitest mocks for execa to avoid actual bd calls in CI.\n\n## Metadata\n- Task-Master ID: 4\n- Complexity: 6/10\n- Original Status: done","status":"closed","priority":0,"issue_type":"epic","owner":"robert@arles.us","created_at":"2026-02-21T01:02:40Z","created_by":"robert","updated_at":"2026-02-21T01:03:18Z","closed_at":"2026-02-21T01:03:18Z","close_reason":"Closed","dependencies":[{"issue_id":"tm2db-aec","depends_on_id":"tm2db-w9p","type":"blocks","created_at":"2026-02-20T17:02:57Z","created_by":"robert","metadata":"{}"}]}
{"id":"tm2db-aec.1","title":"Implement BeadsCli class constructor and private exec() method with execa integration and verbose logging","description":"Create the foundational BeadsCli class structure with constructor accepting projectPath and verbose parameters, and implement the private exec() method that uses execa to run bd commands with proper working directory context and optional verbose logging of commands and output.\n\n## Implementation Details\nImplement the BeadsCli class constructor to store projectPath and verbose settings as private properties. Create the private async exec(args: string[]) method that: (1) logs the command if verbose mode is enabled using console.log with format '[bd] {args}', (2) executes the bd command using execa with the args array and cwd option set to projectPath, (3) logs stdout if verbose and output exists, (4) returns the stdout string. Add basic error handling to propagate execa errors. This provides the foundation for all other CLI methods.","status":"open","priority":2,"issue_type":"task","owner":"robert@arles.us","created_at":"2026-02-21T01:02:46Z","created_by":"robert","updated_at":"2026-02-21T01:02:46Z","dependencies":[{"issue_id":"tm2db-aec.1","depends_on_id":"tm2db-aec","type":"parent-child","created_at":"2026-02-20T17:02:46Z","created_by":"robert","metadata":"{}"}]}
{"id":"tm2db-aec.2","title":"Implement createEpic() and createChild() methods with JSON output parsing and Zod validation","description":"Build the createEpic() and createChild() methods that construct bd create commands with appropriate flags, execute them using the exec() method, parse the JSON output, and validate the result using Zod schema to ensure type safety.\n\n## Implementation Details\nImplement createEpic(title, description, priority): (1) Build args array with ['create', title, '-t', 'epic', '-p', priority.toString(), '--json'], (2) Conditionally add ['-d', description] if description provided, (3) Call exec(args) and parse JSON from stdout, (4) Validate with BeadsCreateOutputSchema.parse() and return typed result. Implement createChild(parentId, title, description): (1) Build args with ['create', title, '--parent', parentId, '--json'], (2) Conditionally add description flag, (3) Execute, parse, and validate same as createEpic(). Both methods return BeadsCreateResult with id, title, and optional type.","status":"open","priority":2,"issue_type":"task","owner":"robert@arles.us","created_at":"2026-02-21T01:02:47Z","created_by":"robert","updated_at":"2026-02-21T01:02:47Z","dependencies":[{"issue_id":"tm2db-aec.2","depends_on_id":"tm2db-aec","type":"parent-child","created_at":"2026-02-20T17:02:46Z","created_by":"robert","metadata":"{}"},{"issue_id":"tm2db-aec.2","depends_on_id":"tm2db-aec.1","type":"blocks","created_at":"2026-02-20T17:03:09Z","created_by":"robert","metadata":"{}"}]}
{"id":"tm2db-aec.3","title":"Implement dependency and status methods (addDependency, updateStatus, close)","description":"Create methods for managing issue relationships and status transitions: addDependency() to link blocking/blocked issues, updateStatus() to change issue state, and close() to mark issues complete.\n\n## Implementation Details\nImplement addDependency(blockedId, blockingId): Execute ['dep', 'add', blockedId, blockingId] via exec(). No JSON parsing needed as this command doesn't return structured output. Implement updateStatus(issueId, status): Execute ['update', issueId, '-s', status] via exec(). Implement close(issueId): Execute ['close', issueId] via exec(). All three methods are async void, relying on exec() to throw on command failures. These methods enable status synchronization (task 9) and dependency management between converted task-master tasks.","status":"open","priority":2,"issue_type":"task","owner":"robert@arles.us","created_at":"2026-02-21T01:02:47Z","created_by":"robert","updated_at":"2026-02-21T01:02:47Z","dependencies":[{"issue_id":"tm2db-aec.3","depends_on_id":"tm2db-aec","type":"parent-child","created_at":"2026-02-20T17:02:47Z","created_by":"robert","metadata":"{}"},{"issue_id":"tm2db-aec.3","depends_on_id":"tm2db-aec.1","type":"blocks","created_at":"2026-02-20T17:03:09Z","created_by":"robert","metadata":"{}"}]}
{"id":"tm2db-aec.4","title":"Implement checkInit() and add comprehensive error handling for command failures with descriptive error messages","description":"Add the checkInit() method to verify .beads directory existence, and enhance all CLI methods with comprehensive error handling that catches execa errors and provides descriptive, actionable error messages for common failure scenarios like missing bd command, non-zero exit codes, and malformed JSON.\n\n## Implementation Details\nImplement checkInit(): Use execa('test', ['-d', '.beads'], { cwd: projectPath }) to check directory existence. Return true if successful, catch error and return false. This is cross-platform via test command. Enhance exec() method with try-catch: (1) Wrap execa call to catch ExecaError, (2) Check for command not found (ENOENT) and throw 'bd command not found - ensure beads is installed', (3) Check for non-zero exit code and include stderr in error message, (4) Preserve stack trace. Enhance JSON parsing methods (createEpic, createChild): (1) Wrap JSON.parse in try-catch for SyntaxError, (2) Throw descriptive error like 'Failed to parse bd output as JSON: {stdout}', (3) Catch Zod validation errors and throw with schema details. This provides debugging information for CLI integration issues.","status":"open","priority":2,"issue_type":"task","owner":"robert@arles.us","created_at":"2026-02-21T01:02:48Z","created_by":"robert","updated_at":"2026-02-21T01:02:48Z","dependencies":[{"issue_id":"tm2db-aec.4","depends_on_id":"tm2db-aec","type":"parent-child","created_at":"2026-02-20T17:02:47Z","created_by":"robert","metadata":"{}"},{"issue_id":"tm2db-aec.4","depends_on_id":"tm2db-aec.1","type":"blocks","created_at":"2026-02-20T17:03:09Z","created_by":"robert","metadata":"{}"},{"issue_id":"tm2db-aec.4","depends_on_id":"tm2db-aec.2","type":"blocks","created_at":"2026-02-20T17:03:10Z","created_by":"robert","metadata":"{}"},{"issue_id":"tm2db-aec.4","depends_on_id":"tm2db-aec.3","type":"blocks","created_at":"2026-02-20T17:03:10Z","created_by":"robert","metadata":"{}"}]}
{"id":"tm2db-brr","title":"Define Zod schemas for task-master-ai input validation","description":"## Description\nCreate TypeScript types and Zod validation schemas for TaskMasterProject, TaskMasterTask, and TaskMasterSubtask matching the PRD specification\n\n## Implementation Details\nCreate src/schemas/taskmaster.ts:\n```typescript\nimport { z } from 'zod';\n\nconst TaskMasterStatusSchema = z.enum(['pending', 'in-progress', 'done', 'deferred']);\nconst TaskMasterPrioritySchema = z.enum(['high', 'medium', 'low']);\n\nexport const TaskMasterSubtaskSchema = z.object({\n  id: z.number(),\n  title: z.string(),\n  description: z.string(),\n  status: TaskMasterStatusSchema,\n  dependencies: z.array(z.number()).optional(),\n  details: z.string().optional()\n});\n\nexport const TaskMasterTaskSchema = z.object({\n  id: z.number(),\n  title: z.string(),\n  description: z.string(),\n  status: TaskMasterStatusSchema,\n  priority: TaskMasterPrioritySchema,\n  dependencies: z.array(z.number()),\n  complexity: z.number().min(1).max(10).optional(),\n  subtasks: z.array(TaskMasterSubtaskSchema).optional(),\n  details: z.string().optional(),\n  testStrategy: z.string().optional()\n});\n\nexport const TaskMasterProjectSchema = z.object({\n  tasks: z.array(TaskMasterTaskSchema)\n});\n\nexport type TaskMasterSubtask = z.infer\u003ctypeof TaskMasterSubtaskSchema\u003e;\nexport type TaskMasterTask = z.infer\u003ctypeof TaskMasterTaskSchema\u003e;\nexport type TaskMasterProject = z.infer\u003ctypeof TaskMasterProjectSchema\u003e;\n```\n\nAdd validation helpers:\n- parseTasksJson(filePath: string): Promise\u003cTaskMasterProject\u003e\n- validateCircularDependencies(tasks: TaskMasterTask[]): boolean\n- validateDependencyIds(tasks: TaskMasterTask[]): boolean\n\n## Test Strategy\nCreate vitest tests in src/schemas/taskmaster.test.ts with fixtures:\n1. Valid tasks.json - should parse successfully\n2. Missing required fields - should throw with descriptive error\n3. Invalid status/priority values - should throw\n4. Circular dependencies - validation should detect\n5. Non-existent dependency IDs - validation should detect\nRun `npm test` to verify all tests pass.\n\n## Metadata\n- Task-Master ID: 2\n- Complexity: 4/10\n- Original Status: done","status":"closed","priority":0,"issue_type":"epic","owner":"robert@arles.us","created_at":"2026-02-21T01:02:40Z","created_by":"robert","updated_at":"2026-02-21T01:03:17Z","closed_at":"2026-02-21T01:03:17Z","close_reason":"Closed","dependencies":[{"issue_id":"tm2db-brr","depends_on_id":"tm2db-w9p","type":"blocks","created_at":"2026-02-20T17:02:56Z","created_by":"robert","metadata":"{}"}]}
{"id":"tm2db-brr.1","title":"Define base Zod schemas with type inference","description":"Create TaskMasterSubtaskSchema, TaskMasterTaskSchema, and TaskMasterProjectSchema using Zod with proper enum definitions for status and priority, including TypeScript type inference exports\n\n## Implementation Details\nCreate src/schemas/taskmaster.ts with Zod schemas matching the TaskMaster data model. Define TaskMasterStatusSchema as z.enum(['pending', 'in-progress', 'done', 'deferred']), TaskMasterPrioritySchema as z.enum(['high', 'medium', 'low']). Build TaskMasterSubtaskSchema with id (number), title (string), description (string), status (TaskMasterStatusSchema), optional dependencies (array of numbers), and optional details (string). Build TaskMasterTaskSchema with id, title, description, status, priority, dependencies (required array), optional complexity (1-10), optional subtasks array, optional details, and optional testStrategy. Build TaskMasterProjectSchema with tasks array. Export type inference using z.infer for TaskMasterSubtask, TaskMasterTask, and TaskMasterProject types.","status":"open","priority":2,"issue_type":"task","owner":"robert@arles.us","created_at":"2026-02-21T01:02:45Z","created_by":"robert","updated_at":"2026-02-21T01:02:45Z","dependencies":[{"issue_id":"tm2db-brr.1","depends_on_id":"tm2db-brr","type":"parent-child","created_at":"2026-02-20T17:02:45Z","created_by":"robert","metadata":"{}"}]}
{"id":"tm2db-brr.2","title":"Implement parseTasksJson with file reading and validation","description":"Create parseTasksJson function that reads a tasks.json file from disk, parses the JSON content, validates against TaskMasterProjectSchema, and returns a typed TaskMasterProject object with descriptive error handling\n\n## Implementation Details\nImplement async parseTasksJson(filePath: string): Promise\u003cTaskMasterProject\u003e function in src/schemas/taskmaster.ts. Use fs.promises.readFile to read the file content, JSON.parse to parse the content, and TaskMasterProjectSchema.parse() for validation. Wrap in try-catch to provide descriptive errors for: (1) File not found errors, (2) JSON parsing errors with line/column info if available, (3) Zod validation errors with field-specific details. Return the validated and typed TaskMasterProject object on success. Consider using TaskMasterProjectSchema.safeParse() for better error message control.","status":"open","priority":2,"issue_type":"task","owner":"robert@arles.us","created_at":"2026-02-21T01:02:46Z","created_by":"robert","updated_at":"2026-02-21T01:02:46Z","dependencies":[{"issue_id":"tm2db-brr.2","depends_on_id":"tm2db-brr","type":"parent-child","created_at":"2026-02-20T17:02:45Z","created_by":"robert","metadata":"{}"},{"issue_id":"tm2db-brr.2","depends_on_id":"tm2db-brr.1","type":"blocks","created_at":"2026-02-20T17:03:07Z","created_by":"robert","metadata":"{}"}]}
{"id":"tm2db-brr.3","title":"Implement dependency validation helpers with graph algorithms","description":"Create validateCircularDependencies and validateDependencyIds functions using graph traversal to detect circular dependency cycles and verify all dependency IDs reference existing tasks\n\n## Implementation Details\nImplement two validation functions in src/schemas/taskmaster.ts: (1) validateCircularDependencies(tasks: TaskMasterTask[]): boolean - Build adjacency list from task dependencies, perform depth-first search (DFS) with visiting/visited sets to detect cycles. Return false if cycle found, true otherwise. Use recursion or stack-based DFS. Track visiting nodes to detect back edges indicating cycles. (2) validateDependencyIds(tasks: TaskMasterTask[]): boolean - Create Set of all valid task IDs, iterate through each task's dependencies array, check if each dependency ID exists in the valid IDs set. Return false if any dependency references non-existent task ID, true if all valid. Consider returning descriptive error objects instead of booleans for better debugging (e.g., { valid: boolean, errors: string[] }).","status":"open","priority":2,"issue_type":"task","owner":"robert@arles.us","created_at":"2026-02-21T01:02:46Z","created_by":"robert","updated_at":"2026-02-21T01:02:46Z","dependencies":[{"issue_id":"tm2db-brr.3","depends_on_id":"tm2db-brr","type":"parent-child","created_at":"2026-02-20T17:02:45Z","created_by":"robert","metadata":"{}"},{"issue_id":"tm2db-brr.3","depends_on_id":"tm2db-brr.1","type":"blocks","created_at":"2026-02-20T17:03:07Z","created_by":"robert","metadata":"{}"}]}
{"id":"tm2db-bv0","title":"Implement topological sort for task dependencies","description":"## Description\nCreate a dependency graph resolver that sorts tasks in topological order, ensuring dependencies are created before dependent tasks, with deterministic ordering\n\n## Implementation Details\nCreate src/utils/topological-sort.ts:\n```typescript\nimport { TaskMasterTask } from '../schemas/taskmaster';\n\nexport interface SortedTask {\n  task: TaskMasterTask;\n  tier: number; // dependency tier (0 = no deps, 1 = depends on tier 0, etc.)\n}\n\nexport function topologicalSort(tasks: TaskMasterTask[]): SortedTask[] {\n  const taskMap = new Map(tasks.map(t =\u003e [t.id, t]));\n  const visited = new Set\u003cnumber\u003e();\n  const visiting = new Set\u003cnumber\u003e(); // for cycle detection\n  const sorted: SortedTask[] = [];\n  const tierMap = new Map\u003cnumber, number\u003e();\n\n  function visit(taskId: number): number {\n    if (visited.has(taskId)) return tierMap.get(taskId)!;\n    if (visiting.has(taskId)) throw new Error(`Circular dependency detected involving task ${taskId}`);\n    \n    const task = taskMap.get(taskId);\n    if (!task) throw new Error(`Task ${taskId} referenced but not found`);\n    \n    visiting.add(taskId);\n    \n    let maxDepTier = -1;\n    for (const depId of task.dependencies) {\n      const depTier = visit(depId);\n      maxDepTier = Math.max(maxDepTier, depTier);\n    }\n    \n    const tier = maxDepTier + 1;\n    tierMap.set(taskId, tier);\n    visiting.delete(taskId);\n    visited.add(taskId);\n    sorted.push({ task, tier });\n    \n    return tier;\n  }\n\n  // Visit all tasks\n  for (const task of tasks) {\n    if (!visited.has(task.id)) visit(task.id);\n  }\n\n  // Sort by tier, then by task ID for deterministic ordering\n  return sorted.sort((a, b) =\u003e {\n    if (a.tier !== b.tier) return a.tier - b.tier;\n    return a.task.id - b.task.id;\n  });\n}\n```\n\n## Test Strategy\nCreate vitest tests:\n1. Tasks with no dependencies - should be tier 0, sorted by ID\n2. Linear dependency chain (3→2→1) - should sort as [1, 2, 3] with correct tiers\n3. Diamond dependency (4→[2,3], 2→1, 3→1) - should have 1 in tier 0, [2,3] in tier 1, 4 in tier 2\n4. Circular dependency - should throw error\n5. Missing dependency ID - should throw error\nVerify deterministic ordering with multiple runs.\n\n## Metadata\n- Task-Master ID: 3\n- Complexity: 5/10\n- Original Status: done","status":"closed","priority":0,"issue_type":"epic","owner":"robert@arles.us","created_at":"2026-02-21T01:02:40Z","created_by":"robert","updated_at":"2026-02-21T01:03:17Z","closed_at":"2026-02-21T01:03:17Z","close_reason":"Closed","dependencies":[{"issue_id":"tm2db-bv0","depends_on_id":"tm2db-brr","type":"blocks","created_at":"2026-02-20T17:02:57Z","created_by":"robert","metadata":"{}"}]}
{"id":"tm2db-bv0.1","title":"Implement DFS-based topological sort with cycle detection","description":"Create the core depth-first search algorithm with visiting/visited set pattern to detect circular dependencies during graph traversal\n\n## Implementation Details\nImplement the `visit()` function that uses a `visiting` Set to track the current recursion stack for cycle detection and a `visited` Set to track completed nodes. The function should throw an error if a task is encountered while in the `visiting` set (indicating a cycle). Create the taskMap for O(1) lookup, initialize the tracking sets, and implement the recursive DFS traversal that processes each task's dependencies before marking the task as visited. Handle edge cases: missing task references should throw descriptive errors, self-references should be detected as cycles, and disconnected components should all be processed.","status":"open","priority":2,"issue_type":"task","owner":"robert@arles.us","created_at":"2026-02-21T01:02:48Z","created_by":"robert","updated_at":"2026-02-21T01:02:48Z","dependencies":[{"issue_id":"tm2db-bv0.1","depends_on_id":"tm2db-bv0","type":"parent-child","created_at":"2026-02-20T17:02:48Z","created_by":"robert","metadata":"{}"}]}
{"id":"tm2db-bv0.2","title":"Add tier calculation logic for dependency levels","description":"Implement the tier assignment system that calculates each task's dependency level based on the maximum tier of its dependencies plus one\n\n## Implementation Details\nExtend the `visit()` function to calculate and return tier values. For each task, recursively visit all dependencies first, track the maximum tier value among all dependencies, then assign the current task's tier as maxDepTier + 1. Store tier values in the `tierMap` for memoization to avoid recalculation. Tasks with no dependencies should get tier 0, tasks depending only on tier-0 tasks should get tier 1, and so on. Ensure the tier calculation happens after cycle detection but before marking as visited. The tier value should be returned from visit() and stored for each processed task.","status":"open","priority":2,"issue_type":"task","owner":"robert@arles.us","created_at":"2026-02-21T01:02:49Z","created_by":"robert","updated_at":"2026-02-21T01:02:49Z","dependencies":[{"issue_id":"tm2db-bv0.2","depends_on_id":"tm2db-bv0","type":"parent-child","created_at":"2026-02-20T17:02:48Z","created_by":"robert","metadata":"{}"},{"issue_id":"tm2db-bv0.2","depends_on_id":"tm2db-bv0.1","type":"blocks","created_at":"2026-02-20T17:03:08Z","created_by":"robert","metadata":"{}"}]}
{"id":"tm2db-bv0.3","title":"Implement deterministic ordering with tier-based sorting","description":"Create the final sorting logic that orders tasks by tier first, then by task ID within each tier to ensure stable, deterministic output\n\n## Implementation Details\nAfter all tasks have been visited and added to the `sorted` array with their tier values, implement the two-level sort: primary sort by tier (ascending) to ensure dependencies come before dependents, secondary sort by task ID (ascending) within each tier to guarantee deterministic ordering regardless of traversal order. The sort comparator should return `a.tier - b.tier` if tiers differ, otherwise `a.task.id - b.task.id`. This ensures that given the same input tasks, the output order is always identical. Export the sorted array as `SortedTask[]` with both task data and tier information preserved.","status":"open","priority":2,"issue_type":"task","owner":"robert@arles.us","created_at":"2026-02-21T01:02:49Z","created_by":"robert","updated_at":"2026-02-21T01:02:49Z","dependencies":[{"issue_id":"tm2db-bv0.3","depends_on_id":"tm2db-bv0","type":"parent-child","created_at":"2026-02-20T17:02:48Z","created_by":"robert","metadata":"{}"},{"issue_id":"tm2db-bv0.3","depends_on_id":"tm2db-bv0.2","type":"blocks","created_at":"2026-02-20T17:03:08Z","created_by":"robert","metadata":"{}"}]}
{"id":"tm2db-s4n","title":"Implement epic creation with rich markdown descriptions","description":"## Description\nCreate the epic creation logic that transforms task-master tasks into Beads epics with formatted descriptions containing implementation details, test strategy, and metadata\n\n## Implementation Details\nCreate src/sync/epic-creator.ts:\n```typescript\nimport { TaskMasterTask } from '../schemas/taskmaster';\nimport { BeadsCli } from '../beads/cli';\nimport { IdMapper } from '../mapping/id-mapper';\n\nfunction mapPriority(tmPriority: 'high' | 'medium' | 'low'): number {\n  const priorityMap = { high: 0, medium: 1, low: 2 };\n  return priorityMap[tmPriority];\n}\n\nfunction formatEpicDescription(task: TaskMasterTask): string {\n  const parts = ['## Description', task.description, ''];\n  \n  if (task.details) {\n    parts.push('## Implementation Details', task.details, '');\n  }\n  \n  if (task.testStrategy) {\n    parts.push('## Test Strategy', task.testStrategy, '');\n  }\n  \n  parts.push('## Metadata');\n  parts.push(`- Task-Master ID: ${task.id}`);\n  if (task.complexity) {\n    parts.push(`- Complexity: ${task.complexity}/10`);\n  }\n  parts.push(`- Original Status: ${task.status}`);\n  \n  return parts.join('\\n');\n}\n\nexport async function createEpic(\n  task: TaskMasterTask,\n  cli: BeadsCli,\n  mapper: IdMapper\n): Promise\u003cstring\u003e {\n  const description = formatEpicDescription(task);\n  const priority = mapPriority(task.priority);\n  \n  const result = await cli.createEpic(task.title, description, priority);\n  mapper.addEpic(task.id, result.id);\n  \n  return result.id;\n}\n\nexport async function createEpics(\n  tasks: TaskMasterTask[],\n  cli: BeadsCli,\n  mapper: IdMapper,\n  onProgress?: (current: number, total: number) =\u003e void\n): Promise\u003cvoid\u003e {\n  for (let i = 0; i \u003c tasks.length; i++) {\n    await createEpic(tasks[i], cli, mapper);\n    if (onProgress) onProgress(i + 1, tasks.length);\n  }\n}\n```\n\n## Test Strategy\nUnit tests:\n1. formatEpicDescription() with all fields - verify markdown format\n2. formatEpicDescription() with minimal fields - verify graceful handling\n3. mapPriority() - verify high→0, medium→1, low→2\n4. createEpic() with mocked BeadsCli - verify correct CLI calls and mapper updates\n5. createEpics() progress callback - verify called with correct counts\nIntegration test with real bd CLI in local environment (manual).\n\n## Metadata\n- Task-Master ID: 6\n- Complexity: 4/10\n- Original Status: done","status":"closed","priority":0,"issue_type":"epic","owner":"robert@arles.us","created_at":"2026-02-21T01:02:41Z","created_by":"robert","updated_at":"2026-02-21T01:03:19Z","closed_at":"2026-02-21T01:03:19Z","close_reason":"Closed","dependencies":[{"issue_id":"tm2db-s4n","depends_on_id":"tm2db-2xd","type":"blocks","created_at":"2026-02-20T17:02:59Z","created_by":"robert","metadata":"{}"},{"issue_id":"tm2db-s4n","depends_on_id":"tm2db-aec","type":"blocks","created_at":"2026-02-20T17:02:58Z","created_by":"robert","metadata":"{}"},{"issue_id":"tm2db-s4n","depends_on_id":"tm2db-brr","type":"blocks","created_at":"2026-02-20T17:02:58Z","created_by":"robert","metadata":"{}"}]}
{"id":"tm2db-s4n.1","title":"Implement formatEpicDescription() helper with markdown generation","description":"Create the formatEpicDescription() function that transforms TaskMasterTask fields into properly formatted markdown with sections for description, implementation details, test strategy, and metadata\n\n## Implementation Details\nImplement formatEpicDescription() in src/sync/epic-creator.ts:\n- Create array to collect markdown parts\n- Add '## Description' section with task.description\n- Conditionally add '## Implementation Details' section if task.details exists\n- Conditionally add '## Test Strategy' section if task.testStrategy exists\n- Add '## Metadata' section with task-master ID, complexity (if present), and original status\n- Join parts with newlines to create properly formatted markdown\n- Handle optional fields gracefully to produce clean output even with minimal data\n- Ensure section formatting is consistent with markdown best practices","status":"open","priority":2,"issue_type":"task","owner":"robert@arles.us","created_at":"2026-02-21T01:02:50Z","created_by":"robert","updated_at":"2026-02-21T01:02:50Z","dependencies":[{"issue_id":"tm2db-s4n.1","depends_on_id":"tm2db-s4n","type":"parent-child","created_at":"2026-02-20T17:02:50Z","created_by":"robert","metadata":"{}"}]}
{"id":"tm2db-s4n.2","title":"Implement mapPriority() helper and createEpic() orchestration function","description":"Create the mapPriority() conversion function and createEpic() function that coordinates BeadsCli calls, JSON parsing, and IdMapper updates\n\n## Implementation Details\nImplement in src/sync/epic-creator.ts:\n- Create mapPriority() function with priorityMap object mapping 'high'→0, 'medium'→1, 'low'→2\n- Verify mapping matches Beads priority conventions\n- Implement createEpic() function that:\n  1. Calls formatEpicDescription() to generate markdown description\n  2. Calls mapPriority() to convert task priority\n  3. Invokes cli.createEpic() with title, description, and priority\n  4. Parses the result to extract epic ID\n  5. Updates mapper with mapper.addEpic(task.id, result.id)\n  6. Returns the epic ID\n- Add proper TypeScript types and error handling\n- Import required types from TaskMasterTask, BeadsCli, and IdMapper modules","status":"open","priority":2,"issue_type":"task","owner":"robert@arles.us","created_at":"2026-02-21T01:02:51Z","created_by":"robert","updated_at":"2026-02-21T01:02:51Z","dependencies":[{"issue_id":"tm2db-s4n.2","depends_on_id":"tm2db-s4n","type":"parent-child","created_at":"2026-02-20T17:02:50Z","created_by":"robert","metadata":"{}"},{"issue_id":"tm2db-s4n.2","depends_on_id":"tm2db-s4n.1","type":"blocks","created_at":"2026-02-20T17:03:11Z","created_by":"robert","metadata":"{}"}]}
{"id":"tm2db-s4n.3","title":"Implement createEpics() batch function with progress callback support","description":"Create the createEpics() batch processing function that iterates through tasks, creates epics sequentially, and provides progress updates via callback\n\n## Implementation Details\nImplement createEpics() in src/sync/epic-creator.ts:\n- Accept parameters: tasks array, BeadsCli instance, IdMapper instance, optional onProgress callback\n- Iterate through tasks array using indexed for loop to track position\n- For each task, call createEpic() with task, cli, and mapper\n- After each epic creation, invoke onProgress callback if provided with (i + 1, tasks.length)\n- Add proper error handling to catch and report failures during epic creation\n- Return Promise\u003cvoid\u003e since function is async\n- Consider adding logging for debugging batch operations\n- Ensure sequential processing to maintain dependency order from prior topological sort","status":"open","priority":2,"issue_type":"task","owner":"robert@arles.us","created_at":"2026-02-21T01:02:51Z","created_by":"robert","updated_at":"2026-02-21T01:02:51Z","dependencies":[{"issue_id":"tm2db-s4n.3","depends_on_id":"tm2db-s4n","type":"parent-child","created_at":"2026-02-20T17:02:50Z","created_by":"robert","metadata":"{}"},{"issue_id":"tm2db-s4n.3","depends_on_id":"tm2db-s4n.2","type":"blocks","created_at":"2026-02-20T17:03:12Z","created_by":"robert","metadata":"{}"}]}
{"id":"tm2db-w9p","title":"Project initialization and TypeScript setup","description":"## Description\nInitialize npm project, configure TypeScript with strict mode, and set up build tooling with tsup or tsx for zero-config execution\n\n## Implementation Details\n1. Run `npm init -y` to create package.json\n2. Install core dependencies: `npm install typescript @types/node zod execa commander chalk --save`\n3. Install dev dependencies: `npm install -D tsup vitest @types/commander tsx --save-dev`\n4. Create tsconfig.json with strict mode enabled:\n```json\n{\n  \"compilerOptions\": {\n    \"target\": \"ES2022\",\n    \"module\": \"ESNext\",\n    \"moduleResolution\": \"bundler\",\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"skipLibCheck\": true,\n    \"forceConsistentCasingInFileNames\": true,\n    \"outDir\": \"./dist\",\n    \"rootDir\": \"./src\",\n    \"declaration\": true\n  },\n  \"include\": [\"src/**/*\"],\n  \"exclude\": [\"node_modules\", \"dist\"]\n}\n```\n5. Create src/ directory structure\n6. Configure package.json scripts:\n   - `\"build\": \"tsup src/index.ts --format esm,cjs --dts\"`\n   - `\"dev\": \"tsx src/index.ts\"`\n   - `\"test\": \"vitest\"`\n7. Create bin entry in package.json pointing to dist/index.js\n8. Update .gitignore to include dist/, node_modules/\n\n## Test Strategy\nVerify TypeScript compilation succeeds with `npm run build`. Verify CLI can be executed with `npm run dev -- --help`. Check that strict type checking is enabled by introducing a type error and confirming compilation fails.\n\n## Metadata\n- Task-Master ID: 1\n- Complexity: 2/10\n- Original Status: done","status":"closed","priority":0,"issue_type":"epic","owner":"robert@arles.us","created_at":"2026-02-21T01:02:39Z","created_by":"robert","updated_at":"2026-02-21T01:03:17Z","closed_at":"2026-02-21T01:03:17Z","close_reason":"Closed"}
{"id":"tm2db-w9p.1","title":"Initialize npm project and install dependencies","description":"Run npm init and install all required production and development dependencies including TypeScript, Zod, execa, commander, chalk, tsup, vitest, and tsx\n\n## Implementation Details\nExecute the following commands in sequence:\n1. Run `npm init -y` to create package.json with defaults\n2. Install production dependencies: `npm install typescript @types/node zod execa commander chalk`\n3. Install dev dependencies: `npm install -D tsup vitest @types/commander tsx`\n4. Verify all packages are listed in package.json under dependencies and devDependencies sections\n5. Ensure node_modules/ directory is created and populated","status":"open","priority":2,"issue_type":"task","owner":"robert@arles.us","created_at":"2026-02-21T01:02:43Z","created_by":"robert","updated_at":"2026-02-21T01:02:43Z","dependencies":[{"issue_id":"tm2db-w9p.1","depends_on_id":"tm2db-w9p","type":"parent-child","created_at":"2026-02-20T17:02:43Z","created_by":"robert","metadata":"{}"}]}
{"id":"tm2db-w9p.2","title":"Create TypeScript configuration with strict mode","description":"Create tsconfig.json with strict type checking, ES2022 target, ESNext module format, and proper directory structure configuration\n\n## Implementation Details\nCreate tsconfig.json in project root with the following configuration:\n- target: ES2022 for modern JavaScript features\n- module: ESNext with bundler moduleResolution\n- Enable all strict mode flags\n- Configure outDir to ./dist and rootDir to ./src\n- Enable declaration files generation\n- Set esModuleInterop and skipLibCheck for compatibility\n- Include src/**/* and exclude node_modules, dist\nThis ensures maximum type safety and proper build output structure.","status":"open","priority":2,"issue_type":"task","owner":"robert@arles.us","created_at":"2026-02-21T01:02:44Z","created_by":"robert","updated_at":"2026-02-21T01:02:44Z","dependencies":[{"issue_id":"tm2db-w9p.2","depends_on_id":"tm2db-w9p","type":"parent-child","created_at":"2026-02-20T17:02:43Z","created_by":"robert","metadata":"{}"},{"issue_id":"tm2db-w9p.2","depends_on_id":"tm2db-w9p.1","type":"blocks","created_at":"2026-02-20T17:03:05Z","created_by":"robert","metadata":"{}"}]}
{"id":"tm2db-w9p.3","title":"Set up source directory structure and create placeholder entry point","description":"Create the src/ directory and basic index.ts entry point file to establish the project structure\n\n## Implementation Details\n1. Create src/ directory in project root\n2. Create src/index.ts with basic CLI structure:\n```typescript\n#!/usr/bin/env node\nimport { Command } from 'commander';\n\nconst program = new Command();\nprogram\n  .name('tm2bd')\n  .description('Sync task-master-ai tasks to Beads issue tracker')\n  .version('0.1.0');\n\nprogram.parse();\n```\n3. Create placeholder directories: src/schemas/, src/utils/, src/beads/, src/sync/, src/mapping/\nThis establishes the foundational structure for subsequent implementation.","status":"open","priority":2,"issue_type":"task","owner":"robert@arles.us","created_at":"2026-02-21T01:02:44Z","created_by":"robert","updated_at":"2026-02-21T01:02:44Z","dependencies":[{"issue_id":"tm2db-w9p.3","depends_on_id":"tm2db-w9p","type":"parent-child","created_at":"2026-02-20T17:02:43Z","created_by":"robert","metadata":"{}"},{"issue_id":"tm2db-w9p.3","depends_on_id":"tm2db-w9p.2","type":"blocks","created_at":"2026-02-20T17:03:06Z","created_by":"robert","metadata":"{}"}]}
{"id":"tm2db-w9p.4","title":"Configure build scripts and package.json metadata","description":"Add npm scripts for build, dev, and test, configure bin entry point, and set up package.json metadata for CLI distribution\n\n## Implementation Details\nUpdate package.json with:\n1. Scripts section:\n   - \"build\": \"tsup src/index.ts --format esm,cjs --dts\" for production builds\n   - \"dev\": \"tsx src/index.ts\" for local development\n   - \"test\": \"vitest\" for running tests\n2. bin field: { \"tm2bd\": \"./dist/index.js\" } to make CLI globally installable\n3. type: \"module\" for ES modules support\n4. Add name, description, version fields\n5. Set files: [\"dist\"] to include only built files in npm package","status":"open","priority":2,"issue_type":"task","owner":"robert@arles.us","created_at":"2026-02-21T01:02:44Z","created_by":"robert","updated_at":"2026-02-21T01:02:44Z","dependencies":[{"issue_id":"tm2db-w9p.4","depends_on_id":"tm2db-w9p","type":"parent-child","created_at":"2026-02-20T17:02:44Z","created_by":"robert","metadata":"{}"},{"issue_id":"tm2db-w9p.4","depends_on_id":"tm2db-w9p.3","type":"blocks","created_at":"2026-02-20T17:03:06Z","created_by":"robert","metadata":"{}"}]}
{"id":"tm2db-w9p.5","title":"Configure .gitignore and verify complete build pipeline","description":"Create .gitignore to exclude build artifacts and dependencies, then run full build verification to ensure the TypeScript setup is complete and functional\n\n## Implementation Details\n1. Create/update .gitignore with:\n   - node_modules/\n   - dist/\n   - .env\n   - *.log\n   - .DS_Store\n   - coverage/\n2. Run complete verification sequence:\n   - `npm run build` to verify production build works\n   - Check dist/ contains esm and cjs outputs\n   - `npm run dev -- --version` to verify CLI execution\n   - Create a simple type error in src/index.ts and run `npx tsc --noEmit` to confirm strict checking\n   - Remove type error and verify clean build\n3. Document setup completion in README.md if needed","status":"open","priority":2,"issue_type":"task","owner":"robert@arles.us","created_at":"2026-02-21T01:02:45Z","created_by":"robert","updated_at":"2026-02-21T01:02:45Z","dependencies":[{"issue_id":"tm2db-w9p.5","depends_on_id":"tm2db-w9p","type":"parent-child","created_at":"2026-02-20T17:02:44Z","created_by":"robert","metadata":"{}"},{"issue_id":"tm2db-w9p.5","depends_on_id":"tm2db-w9p.4","type":"blocks","created_at":"2026-02-20T17:03:07Z","created_by":"robert","metadata":"{}"}]}
{"id":"tm2db-zhm","title":"Implement child task creation for subtasks","description":"## Description\nCreate logic to generate Beads child issues under epics for each task-master subtask, capturing hierarchical IDs and adding to the mapping\n\n## Implementation Details\nCreate src/sync/child-creator.ts:\n```typescript\nimport { TaskMasterTask, TaskMasterSubtask } from '../schemas/taskmaster';\nimport { BeadsCli } from '../beads/cli';\nimport { IdMapper } from '../mapping/id-mapper';\n\nfunction formatChildDescription(subtask: TaskMasterSubtask): string {\n  const parts = [subtask.description];\n  \n  if (subtask.details) {\n    parts.push('', '## Implementation Details', subtask.details);\n  }\n  \n  return parts.join('\\n');\n}\n\nexport async function createChildren(\n  task: TaskMasterTask,\n  epicId: string,\n  cli: BeadsCli,\n  mapper: IdMapper\n): Promise\u003cvoid\u003e {\n  if (!task.subtasks || task.subtasks.length === 0) return;\n  \n  // Sort by subtask ID for deterministic ordering\n  const sortedSubtasks = [...task.subtasks].sort((a, b) =\u003e a.id - b.id);\n  \n  for (const subtask of sortedSubtasks) {\n    const description = formatChildDescription(subtask);\n    const result = await cli.createChild(epicId, subtask.title, description);\n    mapper.addSubtask(task.id, subtask.id, result.id);\n  }\n}\n\nexport async function createAllChildren(\n  tasks: TaskMasterTask[],\n  cli: BeadsCli,\n  mapper: IdMapper,\n  onProgress?: (current: number, total: number) =\u003e void\n): Promise\u003cvoid\u003e {\n  let processed = 0;\n  const totalSubtasks = tasks.reduce((sum, t) =\u003e sum + (t.subtasks?.length || 0), 0);\n  \n  for (const task of tasks) {\n    const epicId = mapper.getEpicId(task.id);\n    if (!epicId) throw new Error(`Epic ID not found for task ${task.id}`);\n    \n    await createChildren(task, epicId, cli, mapper);\n    \n    processed += task.subtasks?.length || 0;\n    if (onProgress) onProgress(processed, totalSubtasks);\n  }\n}\n```\n\n## Test Strategy\nUnit tests:\n1. formatChildDescription() with details - verify format\n2. formatChildDescription() without details - verify minimal format\n3. createChildren() with empty subtasks - should return immediately\n4. createChildren() with multiple subtasks - verify sorted by ID\n5. createAllChildren() progress tracking - verify correct counts\n6. Error handling when epic ID not in mapper\nMock BeadsCli and IdMapper for isolated testing.\n\n## Metadata\n- Task-Master ID: 7\n- Complexity: 4/10\n- Original Status: done","status":"closed","priority":0,"issue_type":"epic","owner":"robert@arles.us","created_at":"2026-02-21T01:02:42Z","created_by":"robert","updated_at":"2026-02-21T01:03:19Z","closed_at":"2026-02-21T01:03:19Z","close_reason":"Closed","dependencies":[{"issue_id":"tm2db-zhm","depends_on_id":"tm2db-2xd","type":"blocks","created_at":"2026-02-20T17:02:59Z","created_by":"robert","metadata":"{}"},{"issue_id":"tm2db-zhm","depends_on_id":"tm2db-aec","type":"blocks","created_at":"2026-02-20T17:02:59Z","created_by":"robert","metadata":"{}"},{"issue_id":"tm2db-zhm","depends_on_id":"tm2db-s4n","type":"blocks","created_at":"2026-02-20T17:03:00Z","created_by":"robert","metadata":"{}"}]}
{"id":"tm2db-zhm.1","title":"Implement formatChildDescription() helper for subtask markdown formatting","description":"Create the formatChildDescription() function that transforms TaskMasterSubtask objects into properly formatted markdown strings for Beads child issue descriptions\n\n## Implementation Details\nImplement formatChildDescription(subtask: TaskMasterSubtask): string that:\n1. Starts with the subtask description as the primary content\n2. Checks if subtask.details exists and is non-empty\n3. If details exist, appends a blank line, '## Implementation Details' header, and the details content\n4. Returns the joined string with newline separators\n5. Handles edge cases: empty descriptions, null/undefined details, whitespace-only details\n\nThis is simpler than epic formatting (no test strategy, priority, dependencies sections) but must still produce clean markdown. Add unit tests covering: (a) subtask with details, (b) subtask without details, (c) subtask with empty string details.","status":"open","priority":2,"issue_type":"task","owner":"robert@arles.us","created_at":"2026-02-21T01:02:52Z","created_by":"robert","updated_at":"2026-02-21T01:02:52Z","dependencies":[{"issue_id":"tm2db-zhm.1","depends_on_id":"tm2db-zhm","type":"parent-child","created_at":"2026-02-20T17:02:52Z","created_by":"robert","metadata":"{}"}]}
{"id":"tm2db-zhm.2","title":"Implement createChildren() function for single task subtask creation with deterministic ordering","description":"Create the createChildren() function that processes all subtasks for a single task, creating Beads child issues under the parent epic with sorted ordering and proper ID mapping\n\n## Implementation Details\nImplement createChildren(task: TaskMasterTask, epicId: string, cli: BeadsCli, mapper: IdMapper): Promise\u003cvoid\u003e that:\n1. Returns immediately if task.subtasks is undefined, null, or empty array\n2. Creates a sorted copy of subtasks using [...task.subtasks].sort((a, b) =\u003e a.id - b.id) for deterministic ordering\n3. Iterates through sorted subtasks sequentially (not parallel to maintain order)\n4. For each subtask: calls formatChildDescription(), invokes cli.createChild(epicId, title, description), captures the result.id\n5. Updates the mapper with mapper.addSubtask(task.id, subtask.id, result.id)\n6. Handles errors from CLI calls gracefully with descriptive error messages\n\nDeterministic ordering is critical because Beads child IDs are typically assigned sequentially (epic-1.1, epic-1.2, etc.) and we want consistent results across runs.","status":"open","priority":2,"issue_type":"task","owner":"robert@arles.us","created_at":"2026-02-21T01:02:53Z","created_by":"robert","updated_at":"2026-02-21T01:02:53Z","dependencies":[{"issue_id":"tm2db-zhm.2","depends_on_id":"tm2db-zhm","type":"parent-child","created_at":"2026-02-20T17:02:52Z","created_by":"robert","metadata":"{}"},{"issue_id":"tm2db-zhm.2","depends_on_id":"tm2db-zhm.1","type":"blocks","created_at":"2026-02-20T17:03:12Z","created_by":"robert","metadata":"{}"}]}
{"id":"tm2db-zhm.3","title":"Implement createAllChildren() batch processor with epic ID resolution and progress tracking","description":"Create the createAllChildren() orchestrator function that processes all tasks' subtasks in batch with epic ID lookup, error handling, and optional progress callbacks\n\n## Implementation Details\nImplement createAllChildren(tasks: TaskMasterTask[], cli: BeadsCli, mapper: IdMapper, onProgress?: (current: number, total: number) =\u003e void): Promise\u003cvoid\u003e that:\n1. Calculates totalSubtasks by reducing over tasks.reduce((sum, t) =\u003e sum + (t.subtasks?.length || 0), 0)\n2. Initializes processed counter at 0\n3. Iterates through tasks sequentially\n4. For each task: (a) looks up epicId using mapper.getEpicId(task.id), (b) throws descriptive error if epicId is undefined/null (indicates epic not created yet - dependency violation), (c) calls createChildren(task, epicId, cli, mapper)\n5. After each task's children are created, increments processed by task.subtasks?.length || 0\n6. Invokes onProgress(processed, totalSubtasks) callback if provided\n7. Handles errors with task context (which task.id failed)\n\nThis mirrors the createAllEpics() pattern from Task 6 but operates at the child level. Progress tracking is important because subtask counts vary widely per task.","status":"open","priority":2,"issue_type":"task","owner":"robert@arles.us","created_at":"2026-02-21T01:02:53Z","created_by":"robert","updated_at":"2026-02-21T01:02:53Z","dependencies":[{"issue_id":"tm2db-zhm.3","depends_on_id":"tm2db-zhm","type":"parent-child","created_at":"2026-02-20T17:02:53Z","created_by":"robert","metadata":"{}"},{"issue_id":"tm2db-zhm.3","depends_on_id":"tm2db-zhm.2","type":"blocks","created_at":"2026-02-20T17:03:12Z","created_by":"robert","metadata":"{}"}]}
